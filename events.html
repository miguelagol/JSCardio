<!-- // Events -->
<!--  Here’s a list of the most useful DOM events, just to take a look at:
      Mouse events:
         - click – when the mouse clicks on an element (touchscreen devices generate it on a tap).
         - contextmenu – when the mouse right-clicks on an element.
         - mouseover / mouseout – when the mouse cursor comes over / leaves an element.
         - mousedown / mouseup – when the mouse button is pressed / released over an element.
         - mousemove – when the mouse is moved.
      Form element events:
         - submit – when the visitor submits a <form>.
         - focus – when the visitor focuses on an element, e.g. on an <input>.
      Keyboard events:
         - keydown and keyup – when the visitor presses and then releases the button.
      Document events
         - DOMContentLoaded – when the HTML is loaded and processed, DOM is fully built.
      CSS events:
         - transitionend – when a CSS-animation finishes.
-->

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!--  Event handlers
      To react on events we can assign a handler – a function that runs in case of an event. -->

<!-- Ways to assign a handler -->

<!-- HTML-attribute -->
<!-- A handler can be set in HTML with an attribute named on<event> -->

<script>
   function eventHandler() {
      alert(
         'HTML + JS (HTML-attribute) \n <input onlick="eventHandler()" type="button" value="HTML + JS (HTML-attribute)"> \n <script> function eventHandler() { alert() } <//script>',
      );
   }
</script>

<!-- To assign a click handler for an input, we can use onclick -->
<input
   class="wider"
   type="button"
   onclick="eventHandler()"
   value="HTML + JS (HTML-attribute)"
/>

<!-- The handler is always in the DOM property: the HTML-attribute is just one of the ways to initialize it. -->

<!--------------------------------------------------------------------------------------------------->

<!-- DOM property -->
<!-- We can assign a handler using a DOM property on<event>. -->
<input
   id="element"
   type="button"
   class="wider"
   value="HTML + JS (DOM-property)"
/>

<script>
   element.onclick = function() {
      alert(
         'HTML + JS (DOM-property) \n <input id="element" type="button" value="HTML + JS (DOM-property)"> \n <script> element.onclick = function () { alert() } <//script>',
      );
   };
</script>

<!-- the same as -->
<input
   type="button"
   value="Only HTML"
   class="wider"
   onclick="alert(`Only HTML \n <input type='button' value='Only HTML' onclick='alert()'>`)"
/>

<!-- DOM-property case matters!
      Assign a handler to elem.onclick, not elem.ONCLICK, because DOM properties are case-sensitive. -->
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- As there’s only one onclick property, we can’t assign more than one event handler. -->
<input
   type="button"
   id="elem"
   class="wider"
   onclick="alert('Only HTML')"
   value="Click me"
/>
<script>
   elem.onclick = function() {
      alert('HTML + JS');
   };

   // The same as
   /*
   function alertSth() {
      alert('HTML + JS');
   }
   
   elem.onclick = alertSth;    // The function should be assigned as alertSth, not alertSth()!!!
   */
</script>

<!--------------------------------------------------------------------------------------------------->

<!-- Accessing the element: this -->
<!-- The value of this inside a handler is the element. The one which has the handler on it. -->
<button onclick="alert(this.innerHTML)">
   Alert Inner HTML by this.innerHTML
</button>

<!--------------------------------------------------------------------------------------------------->

<!-- Don’t use setAttribute for handlers!!!

   Such a call won’t work:
      document.body.setAttribute('onclick', function() { alert(1) });

   a click on <body> will generate errors,
   because attributes are always strings, function becomes a string -->

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- addEventListener -->
<!--  element.addEventListener(event, handler[ , phase])
         event -  Event name, e.g. "click".
         handler  - The handler function.
         phase -  An optional argument, the “phase” for the handler to work.
      
      To remove, exactly the same arguments as addEventListener
         element.removeEventListener(event, handler[, phase]);
      
      -------------------REMEMBER-------------------
      Removal require the same function
-->
<script>
   /* // that doesn't work
   element.addEventListener('click', () => alert('thanks'));
   // ...
   element.removeEventListener('click', () => alert('thanks')); */

   // The handler won’t be removed, because removeEventListener gets another function – with the same code

   // The right way
   function handler() {
      alert('thanks');
   }
   elem.addEventListener('click', handler);
   // ...
   elem.removeEventListener('click', handler);
</script>

<!-- Multiple calls to addEventListener allow to add multiple handlers -->
<input
   id="eleme"
   type="button"
   class="wider"
   value="Multiple calls to addEventListener"
/>
<script>
   function handler1() {
      alert('handler 1');
   }
   function handler2() {
      alert('handler 2');
   }

   eleme.onclick = () => alert('element.onclick');
   eleme.addEventListener('click', handler1);
   eleme.addEventListener('click', handler2);
</script>

<style>
   input {
      transition: width 1s;
      width: 100px;
   }

   .wider {
      width: auto;
   }

   .wide {
      width: 300px;
   }
</style>

<!-- There exist events that can’t be assigned via a DOM-property. Must use addEventListener. For instance, the event transitionend -->
<input
   type="button"
   id="trans"
   onclick="this.classList.toggle('wide')"
   value="Click me"
/>

<script>
   trans.ontransitionend = function() {
      alert('DOM property'); // doesn't work
   };

   trans.addEventListener('transitionend', function() {
      alert('transitionend with addEventListener'); // shows up when the animation finished
   });
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- Event object -->
<!-- When an event happens, the browser creates an event object, puts details into it and passes it as an argument to the handler. -->

<input
   type="button"
   value="Show event type, element and coordinates of the click"
   id="eventObject"
   class="wider"
/>

<!--  event.currentTarget   - Element that handled the event. That’s exactly the same as this, unless you bind this to something else
      event.clientX / event.clientY    - Window-relative coordinates of the cursor, for mouse events.-->
<script>
   eventObject.onclick = function(event) {
      // show event type, element and coordinates of the click
      alert(event.type + ' at ' + event.currentTarget);
      alert('Coordinates: ' + event.clientX + ':' + event.clientY);
   };
</script>

<!--------------------------------------------------------------------------------------------------->

<!-- Object handlers: handleEvent -->
<!-- We can assign an object as an event handler using addEventListener. When an event occurs, its handleEvent method is called with it.-->
<button id="handleEvents">Handle Event</button>

<script>
   handleEvents.addEventListener('click', {
      handleEvent(event) {
         alert(event.type + ' at ' + event.currentTarget);
      },
   });
</script>

<button id="handleMouse">Handle mouse event witch switch</button>

<script>
   class Menu {
      handleEvent(event) {
         switch (event.type) {
            case 'mousedown':
               handleMouse.innerHTML = 'Mouse button pressed';
               break;
            case 'mouseup':
               handleMouse.innerHTML += '... and released';
               break;
         }
      }
   }

   let menu = new Menu();
   handleMouse.addEventListener('mousedown', menu);
   handleMouse.addEventListener('mouseup', menu);
</script>

<!-- the same as -->
<button id="handleMouse2">Handle mouse event</button>

<script>
   class Menu2 {
      handleEvent(event) {
         let eventType =
            'on' + event.type[0].toUpperCase() + event.type.slice(1);
         this[eventType](event);
      }
      onMousedown() {
         handleMouse2.innerHTML = 'Mouse button pressed';
      }
      onMouseup() {
         handleMouse2.innerHTML += '... and released';
      }
   }
   let menu2 = new Menu2();
   handleMouse2.addEventListener('mousedown', menu2);
   handleMouse2.addEventListener('mouseup', menu2);
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- Event delegation -->
<!--  if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them –
      we put a single handler on their common ancestor. -->
<!-- The algorithm:
      1. Put a single handler on the container.
      2. In the handler – check the source element event.target.
      3. If the event happened inside an element that interests us, then handle the event. -->
<style>
   #delegationTable {
      display: block;
      border-collapse: collapse;
   }

   td {
      width: 70px;
      height: 70px;
      vertical-align: middle;
      text-align: center;
      border: 1px solid gray;
      background: beige;
   }

   .clicked {
      background: rgba(245, 183, 180, 0.795);
   }
</style>

<table id="delegationTable">
   <tr>
      <td>1</td>
      <td>2</td>
      <td>3</td>
   </tr>
   <tr>
      <td>4</td>
      <td>5</td>
      <td>6</td>
   </tr>
   <tr>
      <td>7</td>
      <td>8</td>
      <td>9</td>
   </tr>
</table>

<script>
   let selectedTd;
   let table = document.getElementById('delegationTable');
   // Instead of assign an onclick handler to each <td> (can be many)
   // we’ll setup the “catch-all” handler on <table> element.
   // It will use event.target to get the clicked element and highlight it.
   table.onclick = function(event) {
      let target = event.target.closest('td'); // where was the click?
      if (!target) return; // not on td?
      if (!table.contains(target)) return; // is that actually our table’s <td>?
      highlight(target);
   };

   function highlight(td) {
      if (selectedTd) {
         // remove the existing highlight if any
         selectedTd.classList.remove('clicked');
      }
      selectedTd = td;
      selectedTd.classList.add('clicked'); // highlight the new td
   }
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Actions in markup -->
<!-- We can add a handler for the whole menu and data-action attributes for buttons that has the method to call -->
<div id="buttons">
   <button data-action="save">Save</button>
   <!-- All attributes starting with “data-” are available in the dataset property -->
   <button data-action="load">Load</button>
   <button data-action="search">Search</button>
</div>
<script>
   class Button {
      constructor(elem) {
         this._elem = elem;
         elem.onclick = this.onClick.bind(this);
      }

      save() {
         alert('Saving');
      }

      load() {
         alert('Loading');
      }

      search() {
         alert('Searching');
      }

      onClick(event) {
         let action = event.target.dataset.action;
         if (action) {
            this[action](); // this[] because the method is set dynamically
         }
      }
   }

   new Button(buttons);
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- The 'behavior' pattern -->
<!-- The pattern has two parts:
      - We add a special attribute to an element.
      - A document-wide handler tracks events, and if an event happens on an attributed element – performs the action. -->

<!-- Counter -->
<div>Counter: <input type="button" value="1" data-counter /></div>
<div>One more counter: <input type="button" value="2" data-counter /></div>

<script>
   document.addEventListener('click', function(event) {
      if (event.target.dataset.counter != undefined) {
         event.target.value++;
      }
   });
</script>
<br />
<br />

<!-- -------------------REMEMBER------------------- -->
<!-- For document-level handlers – always addEventListener -->

<!-- Toggler -->
<button data-toggle-id="subscribe-mail">
   Show/hide the subscription form
</button>

<form id="subscribe-mail" hidden>Your mail: <input type="email" /></form>

<script>
   document.addEventListener('click', function(event) {
      let id = event.target.dataset.toggleId;
      if (!id) return;

      let element = document.getElementById(id);

      element.hidden = !element.hidden;
   });
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Benefits of Event delegation -->
<!--  -  Simplifies initialization and saves memory: no need to add many handlers.
      -  Less code: when adding or removing elements, no need to add/remove handlers.
      -  DOM modifications: we can mass add/remove elements with innerHTML and alike. -->

<!-- The delegation has its limitations: -->
<!--  -  First, the event must be bubbling. Some events do not bubble.
         Also, low-level handlers should not use event.stopPropagation().
      -  Second, the delegation may add CPU load, because the container-level handler reacts on events in any place of the container,
         no matter if they interest us or not. But usually the load is negligible, so we don’t take it into account. -->

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- Browser default actions -->

<!-- Preventing browser actions -->
<!-- There are two ways to tell the browser we don’t want it to act:
      - The main way is to use the event object. There’s a method event.preventDefault().
      - If the handler is assigned using on<event> (not by addEventListener), then we can just return false from it. -->
<a href="/" onclick="return false">Click here</a>
<!-- Not necessary to return true -->
or
<a href="/" onclick="event.preventDefault()">here</a>
<br />
<br />

Prevent browser actions
<ul id="links" class="links">
   <!-- Menu items are links <a>, not buttons. There are several benefits:
      - Many people like to use “right click” – “open in a new window”. If we use <button> or <span>, that doesn’t work.
      - Search engines follow <a href="..."> links while indexing. -->
   <li><a href="/html">HTML</a></li>
   <li><a href="/javascript">JavaScript</a></li>
   <li><a href="/css">CSS</a></li>
</ul>

<script>
   links.onclick = function(event) {
      if (event.target.nodeName != 'A') return;

      let href = event.target.getAttribute('href');
      alert(href);

      return false; // prevent browser action (don't go to the URL)
   };
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Prevent further events -->
<!-- Certain events flow one into another. If we prevent the first event, there will be no second. -->
<input value="Focus works" onfocus="this.value=''" />
<input
   onmousedown="return false"
   onfocus="this.value=''"
   value="Click me (no focus) / Click TAB when first input focus"
   style="width: 300px"
/>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- event.defaultPrevented -->
<!-- The property event.defaultPrevented is true if the default action was prevented, and false otherwise. -->

<!-- By default the browser on contextmenu event (right mouse click) shows a context menu with standard options.
   We can prevent it and show our own -->
<button>Right-click for browser context menu</button>
<button oncontextmenu="alert('Draw our menu'); return false">
   Right-click for our context menu
</button>
<br />
<br />

<!-- The problem is that when we click on buttonMenu, we get two menus: the button-level and (the event bubbles up)
   the document-level menu. -->
<div id="documentImitation">
   <p>Right-click for the document menu</p>
   <button id="buttonMenu">
      Right-click for the button menu (and document menu too :( )
   </button>
</div>

<script>
   buttonMenu.oncontextmenu = function(event) {
      event.preventDefault();
      alert('Button context menu');
   };

   documentImitation.oncontextmenu = function(event) {
      event.preventDefault();
      alert('Document context menu');
   };
</script>
<br />

<!-- We forever deny access to information about right-clicks for any outer code, including counters that gather statistics and so on. -->
<div id="documentImitation2">
   <p>Right-click for the document menu</p>
   <button id="buttonMenu2">
      Right-click for the button menu (fixed with event.stopPropagation)
   </button>
</div>

<script>
   buttonMenu2.oncontextmenu = function(event) {
      event.preventDefault();
      event.stopPropagation();
      alert('Button context menu');
   };

   documentImitation2.oncontextmenu = function(event) {
      event.preventDefault();
      alert('Document context menu');
   };
</script>
<br />

<!-- An alternative solution would be to check in the document handler if the default action was prevented?
     If it is so, then the event was handled, and we don’t need to react on it. -->
<div id="documentImitation3">
   <p>Right-click for the document menu</p>
   <button id="buttonMenu3">
      Right-click for the button menu (fixed with event.defaultPrevented)
   </button>
</div>

<script>
   buttonMenu3.oncontextmenu = function(event) {
      event.preventDefault();
      alert('Button context menu');
   };

   documentImitation3.oncontextmenu = function(event) {
      if (event.defaultPrevented) return;

      event.preventDefault();
      alert('Document context menu');
   };
</script>
<br />

<!-- -------------------REMEMBER------------------- -->
<!-- event.stopPropagation() and event.preventDefault() (also known as return false) are two different things.
   They are not related to each other. -->

<!--------------------------------------------------------------------------------------------------->

<!-- There are many default browser actions:
      -  mousedown – starts the selection (move the mouse to select).
      -  click on <input type="checkbox"> – checks/unchecks the input.
      -  submit – clicking an <input type="submit"> or hitting Enter inside a form field causes this event to happen,
         and the browser submits the form after it.
      -  wheel – rolling a mouse wheel event has scrolling as the default action.
      -  keydown – pressing a key may lead to adding a character into a field, or other actions.
      -  contextmenu – the event happens on a right-click, the action is to show the browser context menu.
      -  …there are more… 
   
   To prevent a default action – use either event.preventDefault() or return false. The second method works only for handlers
   assigned with on<event>. -->

<!--------------------------------------------------------------------------------------------------->

<!-- Scrolling -->
Current scrol =
<div id="showScroll"></div>

<script>
   window.addEventListener('scroll', function() {
      document.getElementById('showScroll').innerHTML = pageYOffset + 'px';
   });
</script>
<br />

<!-- Prevent scrolling -->
<!--  We can’t prevent scrolling by using event.preventDefault() in onscroll listener, because it triggers after the scroll has already happened.
      But we can prevent scrolling by event.preventDefault() on an event that causes the scroll.
         For instance:
         -  wheel event – a mouse wheel roll (a “scrolling” touchpad action generates it too).
         -  keydown event for pageUp and pageDown.    -->

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- Dispatching custom events -->

<!-- Event constructor -->
<!-- Events form a hierarchy, just like DOM element classes. The root is the built-in Event class. -->
<!-- let event = new Event(event type[, options]);
   Arguments:
   -  event type – may be any string, like "click" or our own like "hey-ho!".
   -  options – the object with two optional properties:
      -  bubbles: true/false – if true, then the event bubbles.
      -  cancelable: true/false – if true, then the “default action” may be prevented.
         Later we’ll see what it means for custom events.
   By default both are false: {bubbles: false, cancelable: false}.
-->

<!-- dispatchEvent -->
<!--  After an event object is created, we should “run” it on an element using the call elem.dispatchEvent(event).
      Then handlers react on it as if it were a regular built-in event. -->
<button id="buttonClick" onclick='console.log("Autoclick!")'>Autoclick</button>

<script>
   let event = new Event('click');
   buttonClick.dispatchEvent(event);
</script>
<br />
<br />

<!-- -------------------REMEMBER------------------- -->
<!-- event.isTrusted -->
<!--  There is a way to tell a “real” user event from a script-generated one.
            event.isTrusted is true for events that come from real user actions and false for script-generated events. -->

<!--------------------------------------------------------------------------------------------------->

<!-- Bubbling example -->
<h3 id="hello">Hello from the script!</h3>

<script>
   // catch on document...
   document.addEventListener('hello', function(event) {
      // We should use addEventListener for our custom events, because on<event> only exists for built-in events,
      // document.onhello doesn’t work.
      console.log('Hello from ' + event.target.tagName); // Hello from H1
   });

   // ...dispatch on elem!
   let event2 = new Event('hello', { bubbles: true });
   hello.dispatchEvent(event2);
</script>
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- MouseEvent, KeyboardEvent and others -->
<!-- Here’s a short list of classes for UI Events from the UI Event specification:
            -  UIEvent
            -  FocusEvent
            -  MouseEvent
            -  WheelEvent
            -  KeyboardEvent
            -  …     -->
<!-- The right constructor allows to specify standard properties for that type of event. -->
<script>
   let mouseClick = new MouseEvent('click', {
      bubbles: true,
      cancelable: true,
      clientX: 100,
      clientY: 100,
   });

   console.log(mouseClick.clientX);
</script>

<!-- Mouse events types -->
<!-- We can split mouse events into two categories: “simple” and “complex” -->

<!-- Simple events (the most used):
      -  mousedown/mouseup    -  Mouse button is clicked/released over an element.
      -  mouseover/mouseout   -  Mouse pointer comes over/out from an element.
      -  mousemove   -  Every mouse move over an element triggers that event.

     Complex events
      -  click    -  Triggers after mousedown and then mouseup over the same element if the left mouse button was used.
      -  contextmenu    -  Triggers after mousedown if the right mouse button was used.
      -  dblclick    -  Triggers after a double click over an element.

Complex events are made of simple ones, so in theory we could live without them.
But they exist, and that’s good, because they are convenient. -->

<!-- Events order
      An action may trigger multiple events.
      For instance, a click first triggers mousedown, when the button is pressed, then mouseup and click when it’s released.
      In cases when a single action initiates multiple events, their order is fixed.
      That is, the handlers are called in the order mousedown → mouseup → click. Events are handled in the same sequence:
      onmouseup finishes before onclick runs. -->

<!-------------------------------------------------------------------------------->

<!-- Getting the button: which -->
<!-- Click-related events always have the which property, which allows to get the exact mouse button.
      event.which == 1 – the left button
      event.which == 2 – the middle button
      event.which == 3 – the right button -->

<!-------------------------------------------------------------------------------->

<!-- Modifiers: shift, alt, ctrl and meta -->
<!-- All mouse events include the information about pressed modifier keys.
   The properties are:
      -  shiftKey
      -  altKey
      -  ctrlKey
      -  metaKey (Cmd for Mac) -->
<button id="modButton">Alt+Shift+Click on me!</button>

<script>
   modButton.onclick = function(event) {
      if (event.altKey && event.shiftKey) {
         alert('Hooray!');
      }
   };
</script>
<br />
<br />

<!--  Attention: on Mac it’s usually Cmd instead of Ctrl
On Windows and Linux there are modifier keys Alt, Shift and Ctrl. On Mac there’s one more: Cmd, it corresponds to the property metaKey.

In most cases when Windows/Linux uses Ctrl, on Mac people use Cmd (Windows user: Ctrl+Enter or Ctrl+A, a Mac user: Cmd+Enter or Cmd+A)

Even if we’d like to force Mac users to Ctrl+click – that’s kind of difficult.
The problem is: a left-click with Ctrl is interpreted as a right-click on Mac, and it generates the contextmenu event,
not click like Windows/Linux. -->

<!-------------------------------------------------------------------------------->

<!--  Keyboard: keydown and keyup -->
<!-- The keydown events happens when a key is pressed down, and then keyup – when it’s released. -->

<!-- event.code and event.key -->
<!-- The key property of the event object allows to get the character, while the code property of the event object allows to
      get the “physical key code”.

   Key	      event.key	   event.code
   Z	         z (lowercase)	KeyZ
   Shift+Z	   Z (uppercase)	KeyZ
   F1	         F1	            F1
   Backspace	Backspace	   Backspace
   Shift	      Shift	         ShiftRight or ShiftLeft        -->

<!-- Every key has the code that depends on its location on the keyboard. 
      -  Letter keys have codes "Key<letter>": "KeyA", "KeyB" etc.
      -  Digit keys have codes: "Digit<number>": "Digit0", "Digit1" etc.
      -  Special keys are coded by their names: "Enter", "Backspace", "Tab" etc. -->

Please, press Ctrl+Z
<script>
   document.addEventListener('keydown', function(event) {
      if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {
         alert('Undo!');
      }
   });
</script>
<br />
<br />

<!-- Auto-repeat -->
<!--  If a key is being pressed for a long enough time, it starts to repeat: the keydown triggers again and again,
      and then when it’s released we finally get keyup.
      For all repeating keys the event object has event.repeat property set to true.  -->

<!-- Default actions -->
<!-- Preventing the default action on keydown can cancel most of them, with the exception of OS-based special keys.
   For instance, on Windows Alt+F4 closes the current browser window. And there’s no way to stop it by preventing the default action
   in JavaScript. -->
<input
   onkeydown="return checkPhoneKey(event.key)"
   placeholder="Phone, please... Don't make a mistake"
   type="tel"
   class="wide"
/>

<script>
   function checkPhoneKey(key) {
      return (
         (key >= '0' && key <= '9') ||
         key == '+' ||
         key == '(' ||
         key == ')' ||
         key == '-'
      );
   }
</script>
<br />
<br />

<input
   onkeydown="return checkPhoneKey2(event.key)"
   placeholder="Phone, please"
   type="tel"
/>

<script>
   function checkPhoneKey2(key) {
      return (
         (key >= '0' && key <= '9') ||
         key == '+' ||
         key == '(' ||
         key == ')' ||
         key == '-' ||
         key == 'ArrowLeft' ||
         key == 'ArrowRight' ||
         key == 'Delete' ||
         key == 'Backspace'
      );
   }
</script>
<br />
<br />

<!-------------------------------------------------------------------------------->

<!-- Coordinates: clientX/Y, pageX/Y -->
<!-- All mouse events have coordinates in two flavours:
      -  Window-relative: clientX and clientY.
      -  Document-relative: pageX and pageY. -->
<input
   onmousemove="this.value=event.clientX+':'+event.clientY"
   value="Mouse over me"
/>
<br />
<br />

<!-------------------------------------------------------------------------------->

<!-- No selection on mousedown -->
<!-- If we want to handle click events ourselves, then the “extra” selection doesn’t look good. -->
<b ondblclick="alert('dblclick')">Double-click me (and select :( )</b>
<br />
<br />

<style>
   #noSelect {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
   }
</style>

<!-- There’s a CSS way to stop the selection: the user-select property -->
Before...
<b id="noSelect" ondblclick="alert(`Yeah! I'm not selected`)">
   Unselectable by double-click (thanks to user-select: none)
</b>
...After
<br />
<br />

<!--  A text selection is the default browser action on mousedown event.
      So the alternative solution would be to handle mousedown and prevent it -->
Before...
<b ondblclick="alert(`Yeah! I'm not selected`)" onmousedown="return false">
   Unselectable by double-click (thanks to onmousedown="return false")
</b>
...After
<br />
<br />

<!-- Instead of preventing the selection, we can cancel it “post-factum” in the event handler. -->
Before...
<b ondblclick="getSelection().removeAllRanges()">
   Double-click me (canceled selection by
   ondblclick="getSelection().removeAllRanges()")
</b>
...After
<br />
<br />

<!-- Preventing copying -->
<!-- If we want to disable selection to protect our content from copy-pasting, then we can use another event: oncopy. -->
<div oncopy="alert('Copying forbidden!');return false">
   Dear user, The copying is forbidden for you. If you know JS or HTML, then you
   can get everything from the page source though.
</div>
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Moving: mouseover/out, mouseenter/leave -->

<!-- The mouseover event occurs when a mouse pointer comes over an element, and mouseout – when it leaves. -->
<!-- These events are special, because they have a relatedTarget. -->
<!--  For mouseover:
      -  event.target – is the element where the mouse came over.
      -  event.relatedTarget – is the element from which the mouse came.

      For mouseout:
      -  event.target – is the element that mouse left.
      -  event.relatedTarget – is the new under-the-pointer element (that mouse left for). -->

<!-- -------------------REMEMBER------------------- -->
<!-- The relatedTarget property can be null. -->
<!-- That just means that the mouse came not from another element, but from out of the window. Or that it left the window. -->

<!-------------------------------------------------------------------------------->

<!-- Events frequency -->
<!--  The mousemove event triggers when the mouse moves. The browser checks the mouse position from time to time.
      And if it notices changes then triggers the events. That means that if the visitor is moving the mouse very fast
      then DOM-elements may be skipped: -->

<!-- “Extra” mouseout when leaving for a child -->
<!-- -------------------REMEMBER------------------- -->
<!--  According to the browser logic, the mouse cursor may be only over a single element at any time –
      the most nested one (and top by z-index). -->

<!-------------------------------------------------------------------------------->

<!-- Events mouseenter and mouseleave -->
<!-- Events mouseenter/mouseleave are like mouseover/mouseout. They also trigger when the mouse pointer enters/leaves the element.
   But there are two differences:
      -  Transitions inside the element are not counted.
      -  Events mouseenter/mouseleave do not bubble.

When the pointer enters an element – the mouseenter triggers, and then doesn’t matter where it goes while inside the element.
The mouseleave event only triggers when the cursor leaves it. Children are ignored. -->

<!-------------------------------------------------------------------------------->

<!-- Event delegation -->
<!-- Events mouseenter/leave are very simple and easy to use. But they do not bubble. So we can’t use event delegation with them. -->
<table id="mouseDelegation">
   <tr>
      <td><strong>1</strong></td>
      <td><strong>2</strong></td>
      <td><strong>3</strong></td>
   </tr>
   <tr>
      <td><strong>4</strong></td>
      <td><strong>5</strong></td>
      <td><strong>6</strong></td>
   </tr>
   <tr>
      <td><strong>7</strong></td>
      <td><strong>8</strong></td>
      <td><strong>9</strong></td>
   </tr>
</table>

<script>
   mouseDelegation.onmouseover = function(event) {
      let target = event.target;
      target.style.background = 'pink';
   };

   mouseDelegation.onmouseout = function(event) {
      let target = event.target;
      target.style.background = '';
   };
</script>
<br />
<br />

<table id="mouseDelegation2">
   <tr>
      <td><strong>1</strong></td>
      <td><strong>2</strong></td>
      <td><strong>3</strong></td>
   </tr>
   <tr>
      <td><strong>4</strong></td>
      <td><strong>5</strong></td>
      <td><strong>6</strong></td>
   </tr>
   <tr>
      <td><strong>7</strong></td>
      <td><strong>8</strong></td>
      <td><strong>9</strong></td>
   </tr>
</table>

<script>
   let currentElem = null;

   mouseDelegation2.onmouseover = function(event) {
      if (currentElem) {
         // before entering a new element, the mouse always leaves the previous one
         // if we didn't leave <td> yet, then we're still inside it, so can ignore the event
         return;
      }

      let target = event.target.closest('td');
      if (!target || !mouseDelegation2.contains(target)) return;

      // yeah we're inside <td> now
      currentElem = target;
      target.style.background = 'pink';
   };

   mouseDelegation2.onmouseout = function(event) {
      // if we're outside of any <td> now, then ignore the event
      if (!currentElem) return;

      // we're leaving the element -- where to? Maybe to a child element?
      let relatedTarget = event.relatedTarget;
      if (relatedTarget) {
         // possible: relatedTarget = null
         while (relatedTarget) {
            // go up the parent chain and check -- if we're still inside currentElem
            // then that's an internal transition -- ignore it
            if (relatedTarget == currentElem) return;
            relatedTarget = relatedTarget.parentNode;
         }
      }

      // we left the element. really.
      currentElem.style.background = '';
      currentElem = null;
   };
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Custom events -->
<!--  For our own, custom events we should use new CustomEvent.
            Technically CustomEvent is the same as Event, with one exception.
            In the second argument (object) we can add an additional property detail
            for any custom information that we want to pass with the event. -->
<h3 id="eventDetail">Hello for Jack!</h3>

<script>
   eventDetail.addEventListener('hello', function(event) {
      console.log(event.detail.name);
   });

   eventDetail.dispatchEvent(
      new CustomEvent('hello', {
         detail: { name: 'Jack' },
      }),
   );
</script>

<!--------------------------------------------------------------------------------------------------->

<!-- event.preventDefault() -->
<!-- We can call event.preventDefault() on a script-generated event if cancelable:true flag is specified. -->
<!--  If the event has a non-standard name, then it’s not known to the browser, and there’s no “default browser action” for it.

      The call of event.preventDefault() is a way for the handler to send a signal that those actions shouldn’t be performed.
      In that case the call to elem.dispatchEvent(event) returns false.
      And the event-generating code knows that the processing shouldn’t continue. -->
<pre id="rabbit">
            |\   /|
             \|_|/
             /. .\
            =\_Y_/=
             {>o<}
</pre>

<script>
   // hide() will be called automatically in 2 seconds
   function hide() {
      let hideRabbit = new CustomEvent('hide', {
         cancelable: true, // without that flag preventDefault doesn't work
      });
      if (!rabbit.dispatchEvent(hideRabbit)) {
         alert('The action was prevented by a handler');
      } else {
         rabbit.hidden = true;
      }
   }

   rabbit.addEventListener('hide', function(event) {
      if (confirm('Call preventDefault?')) {
         event.preventDefault();
      }
   });

   // hide in 2 seconds
   setTimeout(hide, 2000);
</script>

<!--------------------------------------------------------------------------------------------------->

<!-- Events-in-events are synchronous -->
<!--  Usually events are processed asynchronously. That is: if the browser is processing onclick and in the process a new event occurs,
            then it awaits till onclick processing is finished.
            The exception is when one event is initiated from within another one.
            Then the control jumps to the nested event handler, and after it goes back. -->
<button id="nestedMenu">Nested menu (click me)</button>

<script>
   // 1 -> nested -> 2
   nestedMenu.onclick = function() {
      alert(1);

      // alert("nested")
      nestedMenu.dispatchEvent(
         new CustomEvent('menu-open', {
            bubbles: true,
         }),
      );

      alert(2);
   };

   document.addEventListener('menu-open', () => alert('nested'));
</script>

<button id="nestedMenu2">Second nested menu (click me)</button>

<script>
   // 1 -> 2 -> nested
   nestedMenu2.onclick = function() {
      alert(1);

      // alert(2)
      setTimeout(
         () =>
            nestedMenu2.dispatchEvent(
               new CustomEvent('menu-open2', {
                  bubbles: true,
               }),
            ),
         0,
      );

      alert(2);
   };

   document.addEventListener('menu-open2', () => alert('nested'));
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- Drag'n'Drop algorithm -->
<!--  1. Catch mousedown on a draggable element.
      2. Prepare the element for moving (maybe create a copy of it or whatever).
      3. Then on mousemove move it by changing left/top and position:absolute.
      4. On mouseup (button release) – perform all actions related to a finished Drag’n’Drop. -->
Drag'n'Drop the ball anywhere
<img src="https://en.js.cx/clipart/ball.svg" id="draggableBall" />

<script>
   draggableBall.onmousedown = function(event) {
      draggableBall.style.position = 'absolute';
      draggableBall.style.zIndex = 1000;

      let shiftX = event.clientX - draggableBall.getBoundingClientRect().left;
      let shiftY = event.clientY - draggableBall.getBoundingClientRect().top;

      document.body.append(draggableBall);

      moveAt(event.pageX, event.pageY);

      function moveAt(pageX, pageY) {
         draggableBall.style.left = pageX - shiftX + 'px';
         draggableBall.style.top = pageY - shiftY + 'px';
      }

      function onMouseMove(event) {
         moveAt(event.pageX, event.pageY);
      }

      document.addEventListener('mousemove', onMouseMove);

      draggableBall.onmouseup = function() {
         document.removeEventListener('mousemove', onMouseMove);
         draggableBall.onmouseup = null;
      };
   };

   // we must disable the browsers Drag'n'Drop
   draggableBall.ondragstart = function() {
      return false;
   };
</script>
<br />
<br />

<!-- document.elementFromPoint(clientX, clientY) -->
<!-- It returns the most nested element on given window-relative coordinates (or null if coordinates are out of the window). -->

<!-- In the modern HTML standard there’s a draggable global attribute is an enumerated attribute that indicates whether the element can be dragged, using the HTML Drag and Drop API. -->
<style>
   #gate {
      cursor: pointer;
      position: absolute;
      right: 15px;
      width: 83px;
      height: 46px;
   }

   #draggableBall,
   #draggableBall2 {
      cursor: pointer;
      width: 40px;
      height: 40px;
   }
</style>
Drag'n'Drop the ball to the soccer gate
<img src="https://en.js.cx/clipart/ball.svg" id="draggableBall2" />
<img
   src="https://en.js.cx/clipart/soccer-gate.svg"
   id="gate"
   class="droppable"
/>

<script>
   draggableBall2.onmousedown = function(event) {
      draggableBall2.style.position = 'absolute';
      draggableBall2.style.zIndex = 1000;

      let shiftX = event.clientX - draggableBall2.getBoundingClientRect().left;
      let shiftY = event.clientY - draggableBall2.getBoundingClientRect().top;
      let currentDroppable = null;

      document.body.append(draggableBall2);

      moveAt(event.pageX, event.pageY);

      function moveAt(pageX, pageY) {
         draggableBall2.style.left = pageX - shiftX + 'px';
         draggableBall2.style.top = pageY - shiftY + 'px';
      }

      function onMouseMove2(event) {
         moveAt(event.pageX, event.pageY);

         draggableBall2.hidden = true;
         let elemBelow = document.elementFromPoint(
            event.clientX,
            event.clientY,
         );
         draggableBall2.hidden = false;

         if (!elemBelow) return;

         let droppableBelow = elemBelow.closest('.droppable');

         if (currentDroppable != droppableBelow) {
            // note: both values can be null
            //   currentDroppable=null if we were not over a droppable (e.g over an empty space)
            //   droppableBelow=null if we're not over a droppable now, during this event
            if (currentDroppable) {
               leaveDroppable(currentDroppable);
            }

            currentDroppable = droppableBelow;
            if (currentDroppable) {
               enterDroppable(currentDroppable);
            }
         }
      }

      document.addEventListener('mousemove', onMouseMove2);

      draggableBall2.onmouseup = function() {
         document.removeEventListener('mousemove', onMouseMove2);
         draggableBall2.onmouseup = null;
      };
   };

   function enterDroppable(elem) {
      elem.style.background = 'rgb(223, 79, 168)';
   }

   function leaveDroppable(elem) {
      elem.style.background = '';
   }
   // we must disable the browsers Drag'n'Drop
   draggableBall2.ondragstart = function() {
      return false;
   };
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 1 - Hide on click
<br />
<button id="hider">Click to hide the text</button>
<br />
<br />
<div id="text">
   Text
</div>

<script>
   hider.onclick = function() {
      text.style.display = 'none';
   };
</script>
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 2 - Hide self
<br />
<button id="hideSelf" onclick='hideSelf.style.display = "none"'>
   Hide the button
</button>

<!-- or -->
<!-- <button id="hideSelf" onclick='this.hidden = true'>Click to hide the button</button> -->
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 3 - Which handlers run? Which alerts show up? -->
<!--  button.addEventListener("click", () => alert("1"));
      button.removeEventListener("click", () => alert("1"));
      button.onclick = () => alert(2); -->

<!-- 1 and 2 -->

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 4 - Move the ball across the field
<br />
<style>
   #field {
      width: 200px;
      height: 150px;
      border: 10px solid black;
      background-color: green;
      overflow: hidden;
      position: relative;
      cursor: pointer;
   }

   #ball {
      position: absolute;
      left: 0;
      top: 0;
      transition: 1s all;
      width: 40px;
      height: 40px;
   }
</style>

<body style="height:2000px">
   <div id="field">
      <img src="https://en.js.cx/clipart/ball.svg" id="ball" />
   </div>

   <script>
      field.onclick = function(event) {
         let fieldCoords = this.getBoundingClientRect(); // returns the size of an element and its position relative to the viewport.

         // ball coordinates are relative to the field inner left-upper corner
         let left =
            event.clientX -
            fieldCoords.left -
            field.clientLeft -
            ball.offsetWidth / 2;
         let top =
            event.clientY -
            fieldCoords.top -
            field.clientTop -
            ball.offsetWidth / 2;

         // prevent crossing the top field boundary
         if (top < 0) top = 0;

         // prevent crossing the left field boundary
         if (left < 0) left = 0;

         // prevent crossing the right field boundary
         // element.clientWidth -  it's the inner width of an element in pixels.
         //                        It includes padding but excludes borders, margins, and vertical scrollbars (if present).
         if (left + ball.clientWidth > field.clientWidth) {
            left = field.clientWidth - ball.clientWidth;
         }

         // prevent crossing the bottom field boundary
         if (top + ball.clientHeight > field.clientHeight) {
            top = field.clientHeight - ball.clientHeight;
         }

         ball.style.left = left + 'px';
         ball.style.top = top + 'px';
      };
   </script>
</body>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 5 - Create a sliding menu
<br />
<style>
   #span2 {
      display: none;
   }

   #click {
      cursor: pointer;
   }

   #cakes {
      display: none;
   }
</style>

<span id="span1">▶</span>
<span id="span2">▼</span>

<span id="click">Sweeties (click me)!</span>
<ul id="cakes">
   <li>Cake</li>
   <li>Donut</li>
   <li>Honey</li>
</ul>

<script>
   click.onclick = function() {
      span1.style.display = 'none';
      span2.style.display = 'inline';
      cakes.style.display = 'block';
   };
</script>
<br />
<br />

<!-- or -->
<style>
   #sweet {
      display: none;
      margin: 0;
      list-style-type: none;
      padding-left: 20px;
   }

   .title {
      cursor: pointer;
   }

   .title::before {
      content: '▶';
      font-size: 80%;
      color: rgb(28, 114, 28);
      padding-right: 10px;
   }

   .open .title::before {
      content: '▼';
      padding-right: 9px;
   }

   .open #sweet {
      display: block;
   }
</style>

<div id="menu" class="sweeties">
   <span class="title">Show me menu!</span>
   <ul id="sweet">
      <li>Cake</li>
      <li>Donut</li>
      <li>Honey</li>
   </ul>
</div>
<script>
   let menuElem = document.getElementById('menu');
   let titleElem = menuElem.querySelector('.title');

   titleElem.onclick = function() {
      menuElem.classList.toggle('open');
   };
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 6 - Add a closing button
<br />
<style>
   h3 {
      margin: 0;
      padding-bottom: 0.3em;
      font-size: 1.1em;
   }

   p {
      margin: 0;
      padding: 0 0 0.5em;
   }

   .panel {
      background: #f5e1e1;
      padding: 10px 20px 10px;
      border-top: solid 2px #df9b9b;
      position: relative;
   }

   .remove-button {
      position: absolute;
      top: 5px;
      right: 15px;
      font-size: 110%;
      color: darkred;
      right: 10px;
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      cursor: pointer;
   }
</style>

<div>
   <div class="panel">
      <button class="remove-button">[x]</button>
      <h3>Horse</h3>
      <p>
         The horse is one of two extant subspecies of Equus ferus. It is an
         odd-toed ungulate mammal belonging to the taxonomic family Equidae. The
         horse has evolved over the past 45 to 55 million years from a small
         multi-toed creature, Eohippus, into the large, single-toed animal of
         today.
      </p>
   </div>
   <div class="panel">
      <button class="remove-button">[x]</button>
      <h3>Donkey</h3>
      <p>
         The donkey or ass (Equus africanus asinus) is a domesticated member of
         the horse family, Equidae. The wild ancestor of the donkey is the
         African wild ass, E. africanus. The donkey has been used as a working
         animal for at least 5000 years.
      </p>
   </div>
   <div class="panel">
      <button class="remove-button">[x]</button>
      <h3>Cat</h3>
      <p>
         The domestic cat (Latin: Felis catus) is a small, typically furry,
         carnivorous mammal. They are often called house cats when kept as
         indoor pets or simply cats when there is no need to distinguish them
         from other felids and felines. Cats are often valued by humans for
         companionship and for their ability to hunt vermin.
      </p>
   </div>
</div>
<script>
   for (let exit of document.getElementsByClassName('remove-button')) {
      let message = exit.parentElement;

      exit.onclick = function() {
         message.style.display = 'none';
      };
   }
</script>
<br />
<br />

<!-- or -->
<style>
   .pane {
      background: #edf5e1;
      padding: 10px 20px 10px;
      border-top: solid 2px #c4df9b;
      position: relative;
   }
</style>

<div>
   <div class="pane">
      <h3>Horse</h3>
      <p>
         The horse is one of two extant subspecies of Equus ferus. It is an
         odd-toed ungulate mammal belonging to the taxonomic family Equidae. The
         horse has evolved over the past 45 to 55 million years from a small
         multi-toed creature, Eohippus, into the large, single-toed animal of
         today.
      </p>
   </div>
   <div class="pane">
      <h3>Donkey</h3>
      <p>
         The donkey or ass (Equus africanus asinus) is a domesticated member of
         the horse family, Equidae. The wild ancestor of the donkey is the
         African wild ass, E. africanus. The donkey has been used as a working
         animal for at least 5000 years.
      </p>
   </div>
   <div class="pane">
      <h3>Cat</h3>
      <p>
         The domestic cat (Latin: Felis catus) is a small, typically furry,
         carnivorous mammal. They are often called house cats when kept as
         indoor pets or simply cats when there is no need to distinguish them
         from other felids and felines. Cats are often valued by humans for
         companionship and for their ability to hunt vermin.
      </p>
   </div>
</div>

<script>
   let panes = document.querySelectorAll('.pane');

   for (let pane of panes) {
      // element.insertAdjacentHTML(position, text);
      //  method of the Element interface parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree
      //  at a specified position.
      /*  position  - A DOMString representing the position relative to the element; must be one of the following strings:
            'beforebegin': Before the element itself.
            'afterbegin': Just inside the element, before its first child.
            'beforeend': Just inside the element, after its last child.
            'afterend': After the element itself.
         text  - The string to be parsed as HTML or XML and inserted into the tree. */
      pane.insertAdjacentHTML(
         'afterbegin',
         '<button class="remove-button">[x]</button>',
      );
      // button becomes the first child of pane
      pane.firstChild.onclick = () => pane.remove();
   }
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 7 - Create a carousel
<br />
<style>
   #content-box {
      background: #eeeeee;
      height: 150px;
      width: 390px;
      padding: 0px 40px;
      border: 1px solid black;
      border-radius: 15px;
      position: relative;
   }

   .left {
      left: 7px;
   }

   .right {
      right: 7px;
   }

   .arrow {
      position: absolute;
      top: 60px;
      padding: 0px;
      background: #ddd;
      border-radius: 15px;
      border: 1px solid gray;
      font-size: 24px;
      line-height: 24px;
      color: #444;
      display: block;
   }

   .arrow:focus {
      outline: none;
   }

   .arrow:hover {
      background: #ccc;
      cursor: pointer;
   }

   #carousel li {
      display: inline-block;
   }

   #carousel {
      width: 390px;
      overflow: hidden;
      margin: 10px 0px;
   }

   #images {
      height: 130px;
      width: 9999px;
      margin: 0px;
      padding: 0px;
      list-style: none;
      font-size: 0;
      display: block;
   }

   #images img {
      width: 130px;
      height: 130px;
      display: block;
   }
</style>

<div id="content-box">
   <button class="arrow left">⇦</button>
   <div id="carousel">
      <ul id="images">
         <li><img src="https://en.js.cx/carousel/1.png" /></li>
         <li><img src="https://en.js.cx/carousel/2.png" /></li>
         <li><img src="https://en.js.cx/carousel/3.png" /></li>
         <li><img src="https://en.js.cx/carousel/4.png" /></li>
         <li><img src="https://en.js.cx/carousel/5.png" /></li>
         <li><img src="https://en.js.cx/carousel/6.png" /></li>
         <li><img src="https://en.js.cx/carousel/7.png" /></li>
         <li><img src="https://en.js.cx/carousel/8.png" /></li>
         <li><img src="https://en.js.cx/carousel/9.png" /></li>
         <li><img src="https://en.js.cx/carousel/10.png" /></li>
      </ul>
   </div>
   <button class="arrow right">⇨</button>
</div>

<script>
   let margin = 0;
   document.querySelector('.right').onclick = function() {
      margin -= 390;
      margin = Math.max(margin, -1170);
      document.querySelector('#images').style.marginLeft = margin + 'px';
   };
   document.querySelector('.left').onclick = function() {
      margin += 390;
      margin = Math.min(margin, 0);
      document.querySelector('#images').style.marginLeft = margin + 'px';
   };

   // or

   // let imageWidth = 130;
   // let count = 3; // cisible images count

   // let uoList = carousel.querySelector('#images');
   // let uoListElem = carousel.querySelector('li');

   // let position = 0; // ribbon scroll position

   // document.querySelector('.right').onclick = function () {
   //    position -= imageWidth * count;
   //    can only shift the ribbbon for (total ribbon length - visible count) images
   //    position = Math.max(position, -width * (listElems.length - count));
   //    uoList.style.marginLeft = position + 'px';
   // }
   // document.querySelector('.left').onclick = function () {
   //    position += imageWidth * count;
   //    can't move to the left too much, end of images
   //    position = Math.min(position, 0)
   //    uoList.style.marginLeft = position + 'px';
   // }
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 8 - Hide messages with delegation
<br />
<style>
   .pan {
      background: #e1ebf5;
      padding: 10px 20px 10px;
      border-top: solid 2px #9ba8df;
      position: relative;
   }
</style>

<div id="container">
   <div class="pan">
      <h3>Horse</h3>
      <p>
         The horse is one of two extant subspecies of Equus ferus. It is an
         odd-toed ungulate mammal belonging to the taxonomic family Equidae. The
         horse has evolved over the past 45 to 55 million years from a small
         multi-toed creature, Eohippus, into the large, single-toed animal of
         today.
      </p>
      <button class="remove-button">[x]</button>
   </div>
   <div class="pan">
      <h3>Donkey</h3>
      <p>
         The donkey or ass (Equus africanus asinus) is a domesticated member of
         the horse family, Equidae. The wild ancestor of the donkey is the
         African wild ass, E. africanus. The donkey has been used as a working
         animal for at least 5000 years.
      </p>
      <button class="remove-button">[x]</button>
   </div>
   <div class="pan">
      <h3>Cat</h3>
      <p>
         The domestic cat (Latin: Felis catus) is a small, typically furry,
         carnivorous mammal. They are often called house cats when kept as
         indoor pets or simply cats when there is no need to distinguish them
         from other felids and felines. Cats are often valued by humans for
         companionship and for their ability to hunt vermin.
      </p>
      <button class="remove-button">[x]</button>
   </div>
</div>
<script>
   document.addEventListener('click', function(event) {
      if (event.target.className != 'remove-button') return;
      let target = event.target.closest('div');
      target.style.display = 'none';
   });
</script>

<!-- or -->
<!-- container.onclick = function(event) {
         if (event.target.className != 'remove-button') return;

         let pane = event.target.closest('.pane');
         pane.remove();
      };
-->
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 9 - Tree menu
<br />
<!-- Create a tree that shows/hides node children on click:
      A click outside the node title (on an empty space) should not do anything. -->
<ul class="tree" id="tree">
   <li>
      Animals
      <ul>
         <li>
            Mammals
            <ul>
               <li>Cows</li>
               <li>Donkeys</li>
               <li>Dogs</li>
               <li>Tigers</li>
            </ul>
         </li>
         <li>
            Other
            <ul>
               <li>Snakes</li>
               <li>Birds</li>
               <li>Lizards</li>
            </ul>
         </li>
      </ul>
   </li>
   <li>
      Fishes
      <ul>
         <li>
            Aquarium
            <ul>
               <li>Guppy</li>
               <li>Angelfish</li>
            </ul>
         </li>
         <li>
            Sea
            <ul>
               <li>Sea trout</li>
            </ul>
         </li>
      </ul>
   </li>
</ul>

<script>
   for (let li of tree.querySelectorAll('li')) {
      let span = document.createElement('span');
      li.prepend(span);
      span.append(span.nextSibling); // move the text node into span
   }

   tree.onclick = function(event) {
      if (event.target.tagName != 'SPAN') return;
      if (event.target.parentElement.children.length > 1) {
         for (let target of event.target.parentElement.children) {
            target.nextSibling.hidden = !target.nextSibling.hidden;
         }
      }
   };
</script>
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 10 - Sortable table
<br />
<!-- Make the table sortable: clicks on <th> elements should sort it by corresponding column. -->
<table id="grid">
   <thead>
      <tr>
         <th data-type="number">Age</th>
         <th data-type="string">Name</th>
      </tr>
   </thead>
   <tbody>
      <tr>
         <td>5</td>
         <td>John</td>
      </tr>
      <tr>
         <td>2</td>
         <td>Pete</td>
      </tr>
      <tr>
         <td>12</td>
         <td>Ann</td>
      </tr>
      <tr>
         <td>9</td>
         <td>Eugene</td>
      </tr>
      <tr>
         <td>1</td>
         <td>Ilya</td>
      </tr>
   </tbody>
</table>

<script>
   grid.onclick = function(event) {
      if (event.target.tagName !== 'TH') return;

      let index = event.target.cellIndex;
      let tbody = grid.querySelector('tbody');
      let type = event.target.dataset.type;
      sortTrs(index, tbody, type);
   };

   function sortTrs(index, where, type) {
      let table = document.getElementById('grid');
      let sortItems;

      switch (type) {
         case 'string':
            sortItems = function(tr1, tr2) {
               return tr1.children[index].innerHTML <
                  tr2.children[index].innerHTML
                  ? -1
                  : 1;
            };
            break;
         case 'number':
            sortItems = function(tr1, tr2) {
               return (
                  tr1.children[index].innerHTML - tr2.children[index].innerHTML
               );
            };
            break;
      }

      let arrayRows = Array.from(where.rows);
      arrayRows.sort(sortItems);
      where.append(...arrayRows);
   }
</script>
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 11 - Tooltip behavior
<br />
<!-- When a mouse comes over an element with data-tooltip, the tooltip should appear over it, and when it’s gone then hide -->
<style>
   .tooltipOne {
      /* some styles for the tooltip, you can use your own instead */
      position: fixed;
      padding: 10px 20px;
      border: 1px solid #b3c9ce;
      border-radius: 4px;
      text-align: center;
      font: italic 14px/1.3 sans-serif;
      color: #333;
      background: #fff;
      box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
   }
</style>

<div id="testTooltip">
   <button data-tooltip="the tooltip is longer than the element">
      Short button
   </button>
   <button data-tooltip="HTML<br>tooltip">One more button</button>
</div>
<br />

<p>
   Scroll the page to make buttons appear on the top, check if the tooltips show
   up correctly.
</p>

<script>
   testTooltip.onmouseover = function(event) {
      if (!event.target.dataset.tooltip) return;

      let div = document.createElement('div');
      div.classList.add('tooltipOne');
      div.innerHTML = event.target.dataset.tooltip;
      event.target.append(div);

      let coords = event.target.getBoundingClientRect();

      let left = coords.left;

      let top = coords.top - div.offsetHeight - 5;
      if (top < 0) {
         top = coords.top + event.target.offsetHeight + 5;
      }

      div.style.top = top + 'px';
      div.style.left = left + 'px';
   };

   testTooltip.onmouseout = function(event) {
      if (!event.target.dataset.tooltip) return;
      event.target.lastChild.remove();
   };
</script>

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 12 - Why "return false" doesn't work?
<br />
<!-- Why in the code below return false doesn’t work at all? -->
<script>
   function handler1() {
      alert('...');
      return false;
   }
</script>

<a href="http://w3.org" onclick="handler1()">the browser will go to w3.org</a>
<br />

<!--  When the browser reads the on* attribute like onclick, it creates the handler from its content.
      For onclick="handler()" the function will be:
         function(event) {
            handler() // the content of onclick
         }
      The value returned by handler() is not used and does not affect the result. -->

<!-- Solution 1 -->
<script>
   function handler2() {
      alert('...');
      return false;
   }
</script>

<a href="http://w3.org" onclick="return handler2()"
   >w3.org (Solution 1 - with return handler() )</a
>
<br />

<!-- Solution 2 -->
<script>
   function handler3(event) {
      alert('...');
      event.preventDefault();
   }
</script>

<a href="http://w3.org" onclick="handler3(event)"
   >w3.org (Solution 2 - with event.preventDefault() )</a
>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 13 - Catch links in the element
<br />
<fieldset id="contents">
   <legend>#contents</legend>
   <p>
      How about to read <a href="http://wikipedia.org">Wikipedia</a> or visit
      <a href="http://w3.org"><i>W3.org</i></a> and learn about modern
      standards?
   </p>
</fieldset>

<script>
   contents.onclick = function(event) {
      if (
         event.target.tagName == 'A' ||
         event.target.parentElement.tagName == 'A'
      ) {
         let answer = confirm('Do you want to leave?');
         if (!answer) event.preventDefault();
      }
   };
</script>
<br />

<!-- or -->
<fieldset id="contents2">
   <legend>#contents</legend>
   <p>
      How about visit <a href="http://onet.pl"><i>Onet</i></a> and see the news?
   </p>
</fieldset>

<script>
   contents2.onclick = function(event) {
      function handleLink(href) {
         let isLeaving = confirm(`Leave for ${href}?`);
         if (!isLeaving) return false;
      }

      let target = event.target.closest('a');

      if (target && contents2.contains(target)) {
         return handleLink(target.getAttribute('href'));
      }
   };
</script>
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 14 - Image gallery
<br />
<style>
   #largeImg {
      border: solid 1px #ccc;
      width: 550px;
      height: 400px;
      padding: 5px;
   }

   #thumbs a {
      border: solid 1px #ccc;
      width: 100px;
      height: 100px;
      padding: 3px;
      margin: 2px;
      float: left;
   }

   #thumbs a:hover {
      border-color: #ff9900;
   }

   #thumbs li {
      list-style: none;
   }

   #thumbs {
      margin: 0;
      padding: 0;
   }

   #noFloat {
      clear: left;
   }
</style>

<p>
   <img
      id="largeImg"
      src="https://en.js.cx/gallery/img1-lg.jpg"
      alt="Large image"
   />
</p>

<ul id="thumbs">
   <!-- the browser shows a small built-in tooltip on hover with the text from "title" attribute -->
   <li>
      <a href="https://en.js.cx/gallery/img2-lg.jpg" title="Image 2"
         ><img src="https://en.js.cx/gallery/img2-thumb.jpg"
      /></a>
   </li>
   <li>
      <a href="https://en.js.cx/gallery/img3-lg.jpg" title="Image 3"
         ><img src="https://en.js.cx/gallery/img3-thumb.jpg"
      /></a>
   </li>
   <li>
      <a href="https://en.js.cx/gallery/img4-lg.jpg" title="Image 4"
         ><img src="https://en.js.cx/gallery/img4-thumb.jpg"
      /></a>
   </li>
   <li>
      <a href="https://en.js.cx/gallery/img5-lg.jpg" title="Image 5"
         ><img src="https://en.js.cx/gallery/img5-thumb.jpg"
      /></a>
   </li>
   <li>
      <a href="https://en.js.cx/gallery/img6-lg.jpg" title="Image 6"
         ><img src="https://en.js.cx/gallery/img6-thumb.jpg"
      /></a>
   </li>
</ul>

<script>
   thumbs.onclick = function(event) {
      if (!event.target.closest('a')) return;

      let target = event.target.closest('a');

      largeImg.src = target.href;
      largeImg.alt = target.title;

      event.preventDefault();
   };
</script>
<div id="noFloat"></div>
<br />

<!-- or -->
<!--
<script>
   thumbs.onclick = function(event) {
      let thumbnail = event.target.closest('a');

      if (!thumbnail) return;
      showThumbnail(thumbnail.href, thumbnail.title);
      event.preventDefault();
   }

   function showThumbnail(href, title) {
      largeImg.src = href;
      largeImg.alt = title;
   }
</script> -->

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 15 - Selectable list
<br />
<style>
   .selected {
      background: #0f0;
   }

   li {
      cursor: pointer;
   }
</style>

Click on a list item to select it.
<ul id="ul">
   <li>Christopher Robin</li>
   <li>Winnie-the-Pooh</li>
   <li>Tigger</li>
   <li>Kanga</li>
   <li>Rabbit. Just rabbit.</li>
</ul>

<script>
   ul.onclick = function(event) {
      if (event.target.tagName != 'LI') return;

      if (event.ctrlKey || event.metaKey) {
         event.target.classList.add('selected');
      } else {
         for (let li of ul.querySelectorAll('li')) {
            if (li.className) {
               li.classList.toggle('selected');
            }
         }
         event.target.classList.add('selected');
      }
   };

   ul.onmousedown = function() {
      return false;
   };
</script>

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 16 - Improved tooltip behavior
<style>
   .tooltipTwo {
      position: fixed;
      z-index: 100;

      padding: 10px 20px;

      border: 1px solid #b3c9ce;
      border-radius: 4px;
      text-align: center;
      font: italic 14px/1.3 sans-serif;
      color: #333;
      background: #fff;
      box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
   }

   #house {
      margin-top: 50px;
      width: 400px;
      border: 1px solid brown;
   }

   #roof {
      width: 0;
      height: 0;
      border-left: 200px solid transparent;
      border-right: 200px solid transparent;
      border-bottom: 20px solid brown;
      margin-top: -20px;
   }

   p {
      text-align: justify;
      margin: 10px 3px;
   }
</style>

<div data-tooltiptwo="Here is the house interior" id="house">
   <div data-tooltiptwo="Here is the roof" id="roof"></div>

   <p>Once upon a time there was a mother pig who had three little pigs.</p>

   <p>
      The three little pigs grew so big that their mother said to them, "You are
      too big to live here any longer. You must go and build houses for
      yourselves. But take care that the wolf does not catch you."
   </p>

   <p>
      The three little pigs set off. "We will take care that the wolf does not
      catch us," they said.
   </p>

   <p>
      Soon they met a man.
      <a
         href="https://en.wikipedia.org/wiki/The_Three_Little_Pigs"
         data-tooltiptwo="Read on…"
         >Hover over me</a
      >
   </p>
</div>

<script>
   document.onmouseover = function(event) {
      let target = event.target;
      let targetTooltip = target.closest('[data-tooltiptwo]');

      if (!targetTooltip) return;

      let div = document.createElement('div');
      div.classList.add('tooltipTwo');
      div.innerHTML = targetTooltip.dataset.tooltiptwo;
      target.append(div);

      let coords = targetTooltip.getBoundingClientRect();

      let left =
         (coords.right - coords.left) / 2 + coords.left - div.clientWidth / 2;

      let top = coords.top - div.offsetHeight - 5;
      if (top < 0) {
         top = coords.top + target.offsetHeight + 5;
      }

      div.style.top = top + 'px';
      div.style.left = left + 'px';
   };

   document.onmouseout = function(event) {
      let target = event.target;
      if (!target.closest('[data-tooltiptwo]')) return;
      event.target.lastChild.remove();
   };
</script>
<br />

<!-- or -->
<!-- <script>
   let tooltip;

   document.onmouseover = function(event) {
      let anchorElem = event.target.closest('[data-tooltiptwo]');

      if (!anchorElem) return;

      tooltip = showTooltip(anchorElem, anchorElem.dataset.tooltip);
   };

   document.onmouseout = function() {
      if (tooltip) {
         tooltip.remove();
         tooltip = false;
      }
   };

   function showTooltip(anchorElem, html) {
      let tooltipElem = document.createElement('div');
      tooltipElem.className = 'tooltip';
      tooltipElem.innerHTML = html;
      document.body.append(tooltipElem);

      let coords = anchorElem.getBoundingClientRect();

      let left =
         coords.left + (anchorElem.offsetWidth - tooltipElem.offsetWidth) / 2;
      if (left < 0) left = 0;

      let top = coords.top - tooltipElem.offsetHeight - 5;
      if (top < 0) {
         top = coords.top + anchorElem.offsetHeight + 5;
      }

      tooltipElem.style.left = left + 'px';
      tooltipElem.style.top = top + 'px';

      return tooltipElem;
   }
</script>   -->

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 17 - "Smart" tooltip
<br />
<style>
   .hours {
      color: rgb(119, 1, 70);
   }

   .minutes {
      color: rgb(180, 9, 137);
   }

   .seconds {
      color: rgb(223, 79, 168);
   }

   .clock {
      border: 1px dashed black;
      padding: 5px;
      display: inline-block;
      background: rgb(243, 158, 218);
      position: fixed;
      right: 0;
      bottom: 0;
   }

   #tooltipthree {
      position: fixed;
      padding: 10px 20px;
      border: 2px solid #b3c9ce;
      border-radius: 4px;
      text-align: center;
      font: italic 14px/1.3 sans-serif;
      color: #333;
      background: #fff;
      z-index: 100000;
      box-shadow: 3px 3px 3px rgba(0, 0, 0, 0.3);
   }
</style>

<div id="clock" class="clock">
      <!-- <div style="background-color: #0f0; width: 85px; height: 2px" ></div> -->
   <span class="hours">12</span> : <span class="minutes">30</span> :
   <span class="seconds">00</span>
</div>

<div id="tooltipthree" hidden>Tooltip</div>

<script>
   class HoverIntent {
      constructor({ sensitivity = 0.1, interval = 100, clock, over, out }) {
         this.sensitivity = sensitivity;
         this.interval = interval;
         this.clock = clock;
         this.over = over;
         this.out = out;

         this.onMouseMove = this.onMouseMove.bind(this);
         this.onMouseOver = this.onMouseOver.bind(this);
         this.onMouseOut = this.onMouseOut.bind(this);

         this.testSpeed = this.testSpeed.bind(this);

         clock.addEventListener('mouseover', this.onMouseOver);
         clock.addEventListener('mouseout', this.onMouseOut);
      }

      onMouseOver(event) {
         // if we're over the element, then ignore the event
         // we are already measuring the speed
         if (this.isOver) {
            return;
         }

         this.isOver = true;

         // after every mousemove we'll be check the distance
         // between the previous and the current mouse coordinates
         // if it's less than sensivity, then the speed is slow
         this.prevX = event.pageX;
         this.prevY = event.pageY;
         this.prevTime = Date.now();

         clock.addEventListener('mousemove', this.onMouseMove);
         this.checkSpeedInterval = setInterval(this.testSpeed, this.interval);
      }

      onMouseOut(event) {
         if (!event.relatedTarget || !clock.contains(event.relatedTarget)) {
            this.isOver = false;
            this.clock.removeEventListener('mousemove', this.onMouseMove);
            clearInterval(this.checkSpeedInterval);
            if (this.isHover) {
               // if there was a stop over the element
               this.out.call(this.clock, event);
               this.isHover = false;
            }
         }
      }

      onMouseMove(event) {
         this.lastX = event.pageX;
         this.lastY = event.pageY;
         this.lastTime = Date.now();
      }

      testSpeed() {
         let speed;

         if (!this.lastTime || this.lastTime == this.prevTime) {
            // cursor didn't move
            speed = 0;
         } else {
            speed =
               Math.sqrt(
                  Math.pow(this.prevX - this.lastX, 2) +
                     Math.pow(this.prevY - this.lastY, 2),
               ) /
               (this.lastTime - this.prevTime);
         }

         if (speed < this.sensitivity) {
            clearInterval(this.checkSpeedInterval);
            this.isHover = true;
            this.over.call(this.clock, event);
         } else {
            // speed fast, remember new coordinates as the previous ones
            this.prevX = this.lastX;
            this.prevY = this.lastY;
            this.prevTime = this.lastTime;
         }
      }

      destroy() {
         clock.removeEventListener('mousemove', this.onMouseMove);
         clock.removeEventListener('mouseover', this.onMouseOver);
         clock.removeEventListener('mouseout', this.onMouseOut);
      }
   }

   setTimeout(function() {
      new HoverIntent({
         clock,
         over() {
            tooltipthree.style.left = clock.offsetLeft + 'px';
            tooltipthree.style.bottom = clock.offsetHeight + 5 + 'px';
            tooltipthree.hidden = false;
         },
         out() {
            tooltipthree.hidden = true;
         },
      });
   }, 2000);
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 18 - Slider
<style>
   .slider {
      border-radius: 5px;
      background: #e0e0e0;
      background: linear-gradient(left top, #e0e0e0, #eeeeee);
      width: 310px;
      height: 15px;
      margin: 5px;
   }

   .thumb {
      width: 10px;
      height: 25px;
      border-radius: 3px;
      position: relative;
      left: 10px;
      top: -5px;
      background: blue;
      cursor: pointer;
   }
</style>

<div id="slider" class="slider">
   <div class="thumb" id="thumb"></div>
</div>

<script>
   let thumb = document.querySelector('.thumb');

   thumb.onmousedown = function(event) {
      event.preventDefault();

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);

      let shiftX = event.clientX - thumb.getBoundingClientRect().left;

      function onMouseMove(event) {
         let moveLeft =
            event.clientX - shiftX - slider.getBoundingClientRect().left;
         let rightEdge = slider.offsetWidth - thumb.clientWidth;
         if (moveLeft < 0) {
            thumb.style.left = 0;
         } else if (moveLeft > rightEdge) {
            thumb.style.left = rightEdge;
         } else {
            thumb.style.left = moveLeft + 'px';
         }
      }

      function onMouseUp(event) {
         document.removeEventListener('mouseup', onMouseUp);
         document.removeEventListener('mousemove', onMouseMove);
      }
   };

   thumb.ondragstart = function() {
      return false;
   };
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 19 - Drag superheroes around the field
<br />
<style>
   #herosField {
      width: 800px;
      height: 500px;
      float: left;
   }
   .hero {
      background: url(https://js.cx/drag-heroes/heroes.png);
      width: 130px;
      height: 128px;
      float: left;
   }

   #hero1 {
      background-position: 0 0;
   }

   #hero2 {
      background-position: 0 -128px;
   }

   #hero3 {
      background-position: -120px 0;
   }

   #hero4 {
      background-position: -125px -128px;
   }

   #hero5 {
      background-position: -248px -128px;
   }

   #hero6 {
      background-position: -244px 0;
   }

   .draggable {
      cursor: pointer;
   }
</style>

<svg
   id="herosField"
   width="22cm"
   height="14cm"
   viewBox="0 0 1150 720"
   stroke="white"
   version="1.1"
   xmlns="http://www.w3.org/2000/svg"
>
   <rect x="0" y="0" width="1150" height="720" fill="green" />
   <path
      d="M 575,20 L 50,20 50,700 1100,700 1100,20 575,20 575,700 z"
      stroke="white"
      stroke-width="2"
      fill="green"
   />
   <circle
      cx="575"
      cy="360"
      r="91.5"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <circle cx="575" cy="360" r="2" stroke="white" fill="white" />
   <circle cx="160" cy="360" r="2" stroke="white" fill="white" />
   <circle cx="990" cy="360" r="2" stroke="white" fill="white" />
   <path
      d="M 50,324.4 L 40,324.4 40, 396.6 50 396.6 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 1100,324.4 L 1110,324.4 1110,396.6 1100,396.6 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 50,269.4 L 105,269.4 105,451.6 50 451.6 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 1100,269.4 L 1045,269.4 1045,451.6 1100,451.6 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 50,159.4 L 215,159.4 215,561.6 50 561.6 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 1100,159.4 L 935,159.4 935,561.6 1100,561.6 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 215,286.875 A 91.5,91.5 0 0,1 215,433.125 z"
      stroke="white"
      stroke-width="2"
      fill="green"
   />
   <path
      d="M 935,286.875 A 91.5,91.5 0 0,0 935,433.125 z"
      stroke="white"
      stroke-width="2"
      fill="green"
   />
   <path
      d="M 50,30 A 10,10 0 0,0 60,20 L 50,20 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 60,700 A 10,10 0 0,0 50,690 L 50,700 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 1100,690 A 10,10 0 0,0 1090,700 L 1100,700 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
   <path
      d="M 1090,20 A 10,10 0 0,0 1100,30 L 1100,20 z"
      stroke="white"
      stroke-width="2"
      fill-opacity="0"
   />
</svg>

<div class="hero draggable" id="hero1"></div>
<div class="hero draggable" id="hero2"></div>
<div class="hero draggable" id="hero3"></div>
<div class="hero draggable" id="hero4"></div>
<div class="hero draggable" id="hero5"></div>
<div class="hero draggable" id="hero6"></div>

<img src="https://en.js.cx/clipart/ball.svg" class="draggable" />

<div style="clear:both"></div>

<script>
   let isDragging = false;

   document.addEventListener('mousedown', function(event) {
      let dragged = event.target.closest('.draggable');

      if (!dragged) return;

      event.preventDefault();

      dragged.ondragstart = function() {
         return false;
      };

      function onMouseMove(event) {
         moveAt(event.clientX, event.clientY);
      }

      function onMouseUp(event) {
         finishDrag();
      }

      let shiftX, shiftY;

      startDrag(dragged, event.clientX, event.clientY);

      function startDrag(element, clientX, clientY) {
         if (isDragging) return;

         isDragging = true;

         document.addEventListener('mousemove', onMouseMove);
         element.addEventListener('mouseup', onMouseUp);

         shiftX = clientX - element.getBoundingClientRect().left;
         shiftY = clientY - element.getBoundingClientRect().top;

         element.style.position = 'fixed';

         moveAt(clientX, clientY);
      }

      function finishDrag() {
         if (!isDragging) return;

         isDragging = false;

         dragged.style.top = parseInt(dragged.style.top) + pageYOffset + 'px';
         dragged.style.position = 'absolute';

         document.removeEventListener('mousemove', onMouseMove);
         dragged.removeEventListener('mouseup', onMouseUp);
      }

      function moveAt(clientX, clientY) {
         // new window-relative coordinates
         let dragX = clientX - shiftX;
         let dragY = clientY - shiftY;

         // check if the new coordinates are below the bottom window edge
         let dragBottom = dragY + dragged.offsetHeight;

         // below the window? let's scroll the page
         if (dragBottom > window.innerHeight) {
            // window-relative coordinate of document end
            let documentBottom = document.documentElement.getBoundingClientRect()
               .bottom;

            let scrollY = Math.min(documentBottom - dragBottom, 10);

            if (scrollY < 0) scrollY = 0;

            window.scrollBy(0, scrollY);

            // a swift mouse move make put the cursor beyond the document end
            // limit the new dragY by the maximally possible (right at the bottom of the document)
            dragY = Math.min(
               dragY,
               document.documentElement.clientHeight - dragged.offsetHeight,
            );
         }

         // check if the new coordinates are above the top window edge
         if (dragY < 0) {
            let scrollY = Math.min(-dragY, 10);

            if (scrollY < 0) scrollY = 0;

            window.scrollBy(0, -scrollY);

            dragY = Math.max(dragY, 0);
         }

         if (dragX < 0) dragX = 0;

         if (
            dragX >
            document.documentElement.clientWidth - dragged.offsetWidth
         ) {
            dragX = document.documentElement.clientWidth - dragged.offsetWidth;
         }

         dragged.style.left = dragX + 'px';
         dragged.style.top = dragY + 'px';
      }
   });
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 20 - Extended hotkeys
<br />
Please press A, S and D keys
<script>
   function runOnKeys(func, ...codes) {
      let pressed = new Set();

      document.addEventListener('keydown', function(event) {
         pressed.add(event.code);

         for (let code of codes) {
            if (!pressed.has(code)) {
               return;
            }
         }

         pressed.clear();
         func();
      });

      document.addEventListener('keyup', function(event) {
         pressed.delete(event.code);
      });
   }

   runOnKeys(() => alert('Hello!'), 'KeyA', 'KeyS', 'KeyD');
</script>

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 21 - Endless page
<br />

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 22 - Up/down button
<style>
   #matrix {
      width: 400px;
      margin: auto;
      overflow: auto;
      text-align: justify;
   }

   #arrowTop {
      height: 9px;
      width: 14px;
      color: green;
      position: fixed;
      top: 10px;
      left: 10px;
      cursor: pointer;
   }

   #arrowTop:before {
      content: '▲';
   }
</style>

<div id="matrix">
   <script>
      for (let i = 0; i < 2000; i++) document.writeln(i);
   </script>
</div>

<div id="arrowTop"></div>

<script>
   let topArrow = document.querySelector('#arrowTop');
   topArrow.style.display = 'none';

   topArrow.addEventListener('click', function(event) {
      window.scrollTo(0, matrix.offsetTop);
   });

   document.addEventListener('scroll', function(event) {
     pageYOffset > matrix.offsetTop + window.innerHeight ?
       topArrow.style.display = 'block' : topArrow.style.display = 'none'
   });
</script>
<br>

<!--------------------------------------------------------------------------------------------------------------------------------------->

TASK 21
