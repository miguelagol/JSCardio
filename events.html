<!-- // Events -->
<!--  Here’s a list of the most useful DOM events, just to take a look at:
      Mouse events:
         - click – when the mouse clicks on an element (touchscreen devices generate it on a tap).
         - contextmenu – when the mouse right-clicks on an element.
         - mouseover / mouseout – when the mouse cursor comes over / leaves an element.
         - mousedown / mouseup – when the mouse button is pressed / released over an element.
         - mousemove – when the mouse is moved.
      Form element events:
         - submit – when the visitor submits a <form>.
         - focus – when the visitor focuses on an element, e.g. on an <input>.
      Keyboard events:
         - keydown and keyup – when the visitor presses and then releases the button.
      Document events
         - DOMContentLoaded – when the HTML is loaded and processed, DOM is fully built.
      CSS events:
         - transitionend – when a CSS-animation finishes.
-->

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!--  Event handlers
      To react on events we can assign a handler – a function that runs in case of an event. -->

<!-- Ways to assign a handler -->

<!-- HTML-attribute -->
<!-- A handler can be set in HTML with an attribute named on<event> -->

<script>
   function eventHandler() {
      alert(
         'HTML + JS (HTML-attribute) \n <input onlick="eventHandler()" type="button" value="HTML + JS (HTML-attribute)"> \n <script> function eventHandler() { alert() } <//script>',
      );
   }
</script>

<!-- To assign a click handler for an input, we can use onclick -->
<input
   class="wider"
   type="button"
   onclick="eventHandler()"
   value="HTML + JS (HTML-attribute)"
/>

<!-- The handler is always in the DOM property: the HTML-attribute is just one of the ways to initialize it. -->

<!--------------------------------------------------------------------------------------------------->

<!-- DOM property -->
<!-- We can assign a handler using a DOM property on<event>. -->
<input
   id="element"
   type="button"
   class="wider"
   value="HTML + JS (DOM-property)"
/>

<script>
   element.onclick = function() {
      alert(
         'HTML + JS (DOM-property) \n <input id="element" type="button" value="HTML + JS (DOM-property)"> \n <script> element.onclick = function () { alert() } <//script>',
      );
   };
</script>

<!-- the same as -->
<input
   type="button"
   value="Only HTML"
   class="wider"
   onclick="alert(`Only HTML \n <input type='button' value='Only HTML' onclick='alert()'>`)"
/>

<!-- DOM-property case matters!
      Assign a handler to elem.onclick, not elem.ONCLICK, because DOM properties are case-sensitive. -->
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- As there’s only one onclick property, we can’t assign more than one event handler. -->
<input
   type="button"
   id="elem"
   class="wider"
   onclick="alert('Only HTML')"
   value="Click me"
/>
<script>
   elem.onclick = function() {
      alert('HTML + JS');
   };

   // The same as
   /*
   function alertSth() {
      alert('HTML + JS');
   }
   
   elem.onclick = alertSth;    // The function should be assigned as alertSth, not alertSth()!!!
   */
</script>

<!--------------------------------------------------------------------------------------------------->

<!-- Accessing the element: this -->
<!-- The value of this inside a handler is the element. The one which has the handler on it. -->
<button onclick="alert(this.innerHTML)">
   Alert Inner HTML by this.innerHTML
</button>

<!--------------------------------------------------------------------------------------------------->

<!-- Don’t use setAttribute for handlers!!!

   Such a call won’t work:
      document.body.setAttribute('onclick', function() { alert(1) });

   a click on <body> will generate errors,
   because attributes are always strings, function becomes a string -->

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- addEventListener -->
<!--  element.addEventListener(event, handler[ , phase])
         event -  Event name, e.g. "click".
         handler  - The handler function.
         phase -  An optional argument, the “phase” for the handler to work.
      
      To remove, exactly the same arguments as addEventListener
         element.removeEventListener(event, handler[, phase]);
      
      -------------------REMEMBER-------------------
      Removal require the same function
-->
<script>
   /* // that doesn't work
   element.addEventListener('click', () => alert('thanks'));
   // ...
   element.removeEventListener('click', () => alert('thanks')); */

   // The handler won’t be removed, because removeEventListener gets another function – with the same code

   // The right way
   function handler() {
      alert('thanks');
   }
   elem.addEventListener('click', handler);
   // ...
   elem.removeEventListener('click', handler);
</script>

<!-- Multiple calls to addEventListener allow to add multiple handlers -->
<input
   id="eleme"
   type="button"
   class="wider"
   value="Multiple calls to addEventListener"
/>
<script>
   function handler1() {
      alert('handler 1');
   }
   function handler2() {
      alert('handler 2');
   }

   eleme.onclick = () => alert('element.onclick');
   eleme.addEventListener('click', handler1);
   eleme.addEventListener('click', handler2);
</script>

<style>
   input {
      transition: width 1s;
      width: 100px;
   }

   .wider {
      width: auto;
   }

   .wide {
      width: 300px;
   }
</style>

<!-- There exist events that can’t be assigned via a DOM-property. Must use addEventListener. For instance, the event transitionend -->
<input
   type="button"
   id="trans"
   onclick="this.classList.toggle('wide')"
   value="Click me"
/>

<script>
   trans.ontransitionend = function() {
      alert('DOM property'); // doesn't work
   };

   trans.addEventListener('transitionend', function() {
      alert('transitionend with addEventListener'); // shows up when the animation finished
   });
</script>
<br />
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- Event object -->
<!-- When an event happens, the browser creates an event object, puts details into it and passes it as an argument to the handler. -->

<input
   type="button"
   value="Show event type, element and coordinates of the click"
   id="eventObject"
   class="wider"
/>

<!--  event.currentTarget   - Element that handled the event. That’s exactly the same as this, unless you bind this to something else
      event.clientX / event.clientY    - Window-relative coordinates of the cursor, for mouse events.-->
<script>
   eventObject.onclick = function(event) {
      // show event type, element and coordinates of the click
      alert(event.type + ' at ' + event.currentTarget);
      alert('Coordinates: ' + event.clientX + ':' + event.clientY);
   };
</script>

<!--------------------------------------------------------------------------------------------------->

<!-- Object handlers: handleEvent -->
<!-- We can assign an object as an event handler using addEventListener. When an event occurs, its handleEvent method is called with it. -->
<button id="handleEvents">Handle Event</button>

<script>
   handleEvents.addEventListener('click', {
      handleEvent(event) {
         alert(event.type + ' at ' + event.currentTarget);
      },
   });
</script>

<button id="handleMouse">Handle mouse event witch switch</button>

<script>
   class Menu {
      handleEvent(event) {
         switch (event.type) {
            case 'mousedown':
               handleMouse.innerHTML = 'Mouse button pressed';
               break;
            case 'mouseup':
               handleMouse.innerHTML += '... and released';
               break;
         }
      }
   }

   let menu = new Menu();
   handleMouse.addEventListener('mousedown', menu);
   handleMouse.addEventListener('mouseup', menu);
</script>

<!-- the same as -->
<button id="handleMouse2">Handle mouse event</button>

<script>
   class Menu2 {
      handleEvent(event) {
         let eventType =
            'on' + event.type[0].toUpperCase() + event.type.slice(1);
         this[eventType](event);
      }
      onMousedown() {
         handleMouse2.innerHTML = 'Mouse button pressed';
      }
      onMouseup() {
         handleMouse2.innerHTML += '... and released';
      }
   }
   let menu2 = new Menu2();
   handleMouse2.addEventListener('mousedown', menu2);
   handleMouse2.addEventListener('mouseup', menu2);
</script>
<br />
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- Event delegation -->
<!--  if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them –
      we put a single handler on their common ancestor. -->
<!-- The algorithm:
      1. Put a single handler on the container.
      2. In the handler – check the source element event.target.
      3. If the event happened inside an element that interests us, then handle the event. -->
<style>
   #delegationTable {
      display: block;
      border-collapse: collapse;
   }

   td {
      width: 70px;
      height: 70px;
      vertical-align: middle;
      text-align: center;
      border: 1px solid gray;
      background: beige;
   }

   .clicked {
      background: rgba(245, 183, 180, 0.795);
   }
</style>
<table id="delegationTable">
   <tr>
      <td>1</td>
      <td>2</td>
      <td>3</td>
   </tr>
   <tr>
      <td>4</td>
      <td>5</td>
      <td>6</td>
   </tr>
   <tr>
      <td>7</td>
      <td>8</td>
      <td>9</td>
   </tr>
</table>

<script>
   let selectedTd;
   let table = document.getElementById('delegationTable');
   // Instead of assign an onclick handler to each <td> (can be many)
   // we’ll setup the “catch-all” handler on <table> element.
   // It will use event.target to get the clicked element and highlight it.
   table.onclick = function(event) {
      let target = event.target.closest('td'); // where was the click?
      if (!target) return; // not on td?
      if (!table.contains(target)) return; // is that actually our table’s <td>?
      highlight(target);
   };

   function highlight(td) {
      if (selectedTd) {
         // remove the existing highlight if any
         selectedTd.classList.remove('clicked');
      }
      selectedTd = td;
      selectedTd.classList.add('clicked'); // highlight the new td
   }
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Actions in markup -->
<!-- We can add a handler for the whole menu and data-action attributes for buttons that has the method to call -->
<div id="buttons">
   <button data-action="save">Save</button>
   <!-- All attributes starting with “data-” are available in the dataset property -->
   <button data-action="load">Load</button>
   <button data-action="search">Search</button>
</div>
<script>
   class Button {
      constructor(elem) {
         this._elem = elem;
         elem.onclick = this.onClick.bind(this);
      }

      save() {
         alert('Saving');
      }

      load() {
         alert('Loading');
      }

      search() {
         alert('Searching');
      }

      onClick(event) {
         let action = event.target.dataset.action;
         if (action) {
            this[action](); // this[] because the method is set dynamically
         }
      }
   }

   new Button(buttons);
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- The 'behavior' pattern -->
<!-- The pattern has two parts:
      - We add a special attribute to an element.
      - A document-wide handler tracks events, and if an event happens on an attributed element – performs the action. -->

<!-- Counter -->
<div>Counter: <input type="button" value="1" data-counter /></div>
<div>One more counter: <input type="button" value="2" data-counter /></div>

<script>
   document.addEventListener('click', function(event) {
      if (event.target.dataset.counter != undefined) {
         event.target.value++;
      }
   });
</script>
<br />
<br />

<!-- -------------------REMEMBER------------------- -->
<!-- For document-level handlers – always addEventListener -->

<!-- Toggler -->
<button data-toggle-id="subscribe-mail">
   Show/hide the subscription form
</button>

<form id="subscribe-mail" hidden>Your mail: <input type="email" /></form>

<script>
   document.addEventListener('click', function(event) {
      let id = event.target.dataset.toggleId;
      if (!id) return;

      let element = document.getElementById(id);

      element.hidden = !element.hidden;
   });
</script>
<br />
<br />

<!--------------------------------------------------------------------------------------------------->

<!-- Benefits of Event delegation -->
<!--  -  Simplifies initialization and saves memory: no need to add many handlers.
      -  Less code: when adding or removing elements, no need to add/remove handlers.
      -  DOM modifications: we can mass add/remove elements with innerHTML and alike. -->

<!-- The delegation has its limitations: -->
<!--  -  First, the event must be bubbling. Some events do not bubble.
         Also, low-level handlers should not use event.stopPropagation().
      -  Second, the delegation may add CPU load, because the container-level handler reacts on events in any place of the container,
         no matter if they interest us or not. But usually the load is negligible, so we don’t take it into account. -->

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 1 - Hide on click -->
<button id="hider">Click to hide the text</button>
<br />
<br />
<div id="text">
   Text
</div>

<script>
   hider.onclick = function() {
      text.style.display = 'none';
   };
</script>
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 2 - Hide self -->
<button id="hideSelf" onclick='hideSelf.style.display = "none"'>
   Hide the button
</button>

<!-- or -->
<!-- <button id="hideSelf" onclick='this.hidden = true'>Click to hide the button</button> -->
<br />
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 3 - Which handlers run? Which alerts show up? -->
<!--  button.addEventListener("click", () => alert("1"));
      button.removeEventListener("click", () => alert("1"));
      button.onclick = () => alert(2); -->

<!-- 1 and 2 -->

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 4 - Move the ball across the field -->
<style>
   #field {
      width: 200px;
      height: 150px;
      border: 10px solid black;
      background-color: green;
      overflow: hidden;
      position: relative;
      cursor: pointer;
   }

   #ball {
      position: absolute;
      left: 0;
      top: 0;
      transition: 1s all;
      width: 40px;
      height: 40px;
   }
</style>

<body style="height:2000px">
   <div id="field">
      <img src="https://en.js.cx/clipart/ball.svg" id="ball" />
   </div>

   <script>
      field.onclick = function(event) {
         let fieldCoords = this.getBoundingClientRect(); // returns the size of an element and its position relative to the viewport.

         // ball coordinates are relative to the field inner left-upper corner
         let left =
            event.clientX -
            fieldCoords.left -
            field.clientLeft -
            ball.offsetWidth / 2;
         let top =
            event.clientY -
            fieldCoords.top -
            field.clientTop -
            ball.offsetWidth / 2;

         // prevent crossing the top field boundary
         if (top < 0) top = 0;

         // prevent crossing the left field boundary
         if (left < 0) left = 0;

         // prevent crossing the right field boundary
         // element.clientWidth -  it's the inner width of an element in pixels.
         //                        It includes padding but excludes borders, margins, and vertical scrollbars (if present).
         if (left + ball.clientWidth > field.clientWidth) {
            left = field.clientWidth - ball.clientWidth;
         }

         // prevent crossing the bottom field boundary
         if (top + ball.clientHeight > field.clientHeight) {
            top = field.clientHeight - ball.clientHeight;
         }

         ball.style.left = left + 'px';
         ball.style.top = top + 'px';
      };
   </script>
</body>
<br />
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 5 - Create a sliding menu -->
<style>
   #span2 {
      display: none;
   }

   #click {
      cursor: pointer;
   }

   #cakes {
      display: none;
   }
</style>
<span id="span1">▶</span>
<span id="span2">▼</span>

<span id="click">Sweeties (click me)!</span>
<ul id="cakes">
   <li>Cake</li>
   <li>Donut</li>
   <li>Honey</li>
</ul>

<script>
   click.onclick = function() {
      span1.style.display = 'none';
      span2.style.display = 'inline';
      cakes.style.display = 'block';
   };
</script>
<br />
<br />

<!-- or -->
<style>
   ul {
      display: none;
      margin: 0;
      list-style-type: none;
      padding-left: 20px;
   }

   .title {
      cursor: pointer;
   }

   .title::before {
      content: '▶';
      font-size: 80%;
      color: rgb(28, 114, 28);
      padding-right: 10px;
   }

   .open .title::before {
      content: '▼';
      padding-right: 9px;
   }

   .open ul {
      display: block;
   }
</style>
<div id="menu" class="sweeties">
   <span class="title">Show me menu!</span>
   <ul>
      <li>Cake</li>
      <li>Donut</li>
      <li>Honey</li>
   </ul>
</div>
<script>
   let menuElem = document.getElementById('menu');
   let titleElem = menuElem.querySelector('.title');

   titleElem.onclick = function() {
      menuElem.classList.toggle('open');
   };
</script>
<br />
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 6 - Add a closing button -->
<style>
   h3 {
      margin: 0;
      padding-bottom: 0.3em;
      font-size: 1.1em;
   }

   p {
      margin: 0;
      padding: 0 0 0.5em;
   }

   .panel {
      background: #f5e1e1;
      padding: 10px 20px 10px;
      border-top: solid 2px #df9b9b;
      position: relative;
   }

   .remove-button {
      position: absolute;
      top: 5px;
      right: 15px;
      font-size: 110%;
      color: darkred;
      right: 10px;
      width: 24px;
      height: 24px;
      border: none;
      background: transparent;
      cursor: pointer;
   }
</style>
<div>
   <div class="panel">
      <button class="remove-button">[x]</button>
      <h3>Horse</h3>
      <p>
         The horse is one of two extant subspecies of Equus ferus. It is an
         odd-toed ungulate mammal belonging to the taxonomic family Equidae. The
         horse has evolved over the past 45 to 55 million years from a small
         multi-toed creature, Eohippus, into the large, single-toed animal of
         today.
      </p>
   </div>
   <div class="panel">
      <button class="remove-button">[x]</button>
      <h3>Donkey</h3>
      <p>
         The donkey or ass (Equus africanus asinus) is a domesticated member of
         the horse family, Equidae. The wild ancestor of the donkey is the
         African wild ass, E. africanus. The donkey has been used as a working
         animal for at least 5000 years.
      </p>
   </div>
   <div class="panel">
      <button class="remove-button">[x]</button>
      <h3>Cat</h3>
      <p>
         The domestic cat (Latin: Felis catus) is a small, typically furry,
         carnivorous mammal. They are often called house cats when kept as
         indoor pets or simply cats when there is no need to distinguish them
         from other felids and felines. Cats are often valued by humans for
         companionship and for their ability to hunt vermin.
      </p>
   </div>
</div>
<script>
   for (let exit of document.getElementsByClassName('remove-button')) {
      let message = exit.parentElement;

      exit.onclick = function() {
         message.style.display = 'none';
      };
   }
</script>
<br />
<br />

<!-- or -->
<style>
   .pane {
      background: #edf5e1;
      padding: 10px 20px 10px;
      border-top: solid 2px #c4df9b;
      position: relative;
   }
</style>
<div>
   <div class="pane">
      <h3>Horse</h3>
      <p>
         The horse is one of two extant subspecies of Equus ferus. It is an
         odd-toed ungulate mammal belonging to the taxonomic family Equidae. The
         horse has evolved over the past 45 to 55 million years from a small
         multi-toed creature, Eohippus, into the large, single-toed animal of
         today.
      </p>
   </div>
   <div class="pane">
      <h3>Donkey</h3>
      <p>
         The donkey or ass (Equus africanus asinus) is a domesticated member of
         the horse family, Equidae. The wild ancestor of the donkey is the
         African wild ass, E. africanus. The donkey has been used as a working
         animal for at least 5000 years.
      </p>
   </div>
   <div class="pane">
      <h3>Cat</h3>
      <p>
         The domestic cat (Latin: Felis catus) is a small, typically furry,
         carnivorous mammal. They are often called house cats when kept as
         indoor pets or simply cats when there is no need to distinguish them
         from other felids and felines. Cats are often valued by humans for
         companionship and for their ability to hunt vermin.
      </p>
   </div>
</div>

<script>
   let panes = document.querySelectorAll('.pane');

   for (let pane of panes) {
      // element.insertAdjacentHTML(position, text);
      //  method of the Element interface parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position.
      /*  position  - A DOMString representing the position relative to the element; must be one of the following strings:
            'beforebegin': Before the element itself.
            'afterbegin': Just inside the element, before its first child.
            'beforeend': Just inside the element, after its last child.
            'afterend': After the element itself.
         text  - The string to be parsed as HTML or XML and inserted into the tree. */
      pane.insertAdjacentHTML(
         'afterbegin',
         '<button class="remove-button">[x]</button>',
      );
      // button becomes the first child of pane
      pane.firstChild.onclick = () => pane.remove();
   }
</script>
<br />
<br />

<!------------------------------------------------------------------------------------------------------------------------------------------------->

<!-- TASK 7 - Create a carousel -->
<style>
   #content-box {
      background: #eeeeee;
      height: 150px;
      width: 390px;
      padding: 0px 40px;
      border: 1px solid black;
      border-radius: 15px;
      position: relative;
   }

   .left {
      left: 7px;
   }

   .right {
      right: 7px;
   }

   .arrow {
      position: absolute;
      top: 60px;
      padding: 0px;
      background: #ddd;
      border-radius: 15px;
      border: 1px solid gray;
      font-size: 24px;
      line-height: 24px;
      color: #444;
      display: block;
   }

   .arrow:focus {
      outline: none;
   }

   .arrow:hover {
      background: #ccc;
      cursor: pointer;
   }

   #carousel li {
      display: inline-block;
   }

   #carousel {
      width: 390px;
      overflow: hidden;
      margin: 10px 0px;
   }

   #images {
      height: 130px;
      width: 9999px;
      margin: 0px;
      padding: 0px;
      list-style: none;
      font-size: 0;
      display: block;
   }

   img {
      width: 130px;
      height: 130px;
      display: block;
   }
</style>
<div id="content-box">
   <button class="arrow left">⇦</button>
   <div id="carousel">
      <ul id="images">
         <li><img src="https://en.js.cx/carousel/1.png" /></li>
         <li><img src="https://en.js.cx/carousel/2.png" /></li>
         <li><img src="https://en.js.cx/carousel/3.png" /></li>
         <li><img src="https://en.js.cx/carousel/4.png" /></li>
         <li><img src="https://en.js.cx/carousel/5.png" /></li>
         <li><img src="https://en.js.cx/carousel/6.png" /></li>
         <li><img src="https://en.js.cx/carousel/7.png" /></li>
         <li><img src="https://en.js.cx/carousel/8.png" /></li>
         <li><img src="https://en.js.cx/carousel/9.png" /></li>
         <li><img src="https://en.js.cx/carousel/10.png" /></li>
      </ul>
   </div>
   <button class="arrow right">⇨</button>
</div>

<script>
   let margin = 0;
   document.querySelector('.right').onclick = function() {
      margin -= 390;
      margin = Math.max(margin, -1170);
      document.querySelector('#images').style.marginLeft = margin + 'px';
   };
   document.querySelector('.left').onclick = function() {
      margin += 390;
      margin = Math.min(margin, 0);
      document.querySelector('#images').style.marginLeft = margin + 'px';
   };

   // or

   // let imageWidth = 130;
   // let count = 3; // cisible images count

   // let uoList = carousel.querySelector('#images');
   // let uoListElem = carousel.querySelector('li');

   // let position = 0; // ribbon scroll position

   // document.querySelector('.right').onclick = function () {
   //    position -= imageWidth * count;
   //    can only shift the ribbbon for (total ribbon length - visible count) images
   //    position = Math.max(position, -width * (listElems.length - count));
   //    uoList.style.marginLeft = position + 'px';
   // }
   // document.querySelector('.left').onclick = function () {
   //    position += imageWidth * count;
   //    can't move to the left too much, end of images
   //    position = Math.min(position, 0)
   //    uoList.style.marginLeft = position + 'px';
   // }
</script>
